
from .errors import StateError
from .utils import import_
from .globals import aliases

#####################################################################################################################################################
#####
#####  VALUE objects
#####

class Value:
    """
    Value of an item's attribute, or a part of it. Provides schema-aware serialization.
    """

    def getstate(self, schema):
        """
        Return self's value encoded into standard JSON-serializable python types: list/dict/str/number...
        get() differs from a standard __getstate__ by accepting a schema definition,
        which may contain additional type constraints and therefore be used to reduce
        the amount of information generated by get() and subsequently stored in DB.
        It is guaranteed that the same - or more specific - schema will be passed to set()
        during deserialization, so that deserialization process has all the same - or more
        - information about type constraints as serialization did.
        If, for any reason, a less specific schema is passed to set(), the client must ensure that
        the default rules of imputation during data decoding will correctly make up for the missing
        values originally predefined by the schema.
        """
        return self.__dict__.copy()

    def setstate(self, state, schema):
        
        if not isinstance(state, dict): raise StateError
        self.__dict__ = state.copy()
    

#####################################################################################################################################################

class String(Value):
    
    string = ""

    def getstate(self, schema):
        return self.string

    def setstate(self, state, schema):
        if not isinstance(state, str): raise StateError(f"expected <str> instead of {state}")
        self.string = state

class Class(Value):
    """Value wrapper around a python class."""
    
    class_ = None
    
    def getstate(self, schema):
        if self.class_ is None: return None
        cls = self.class_
        classname = cls.__module__ + "." + cls.__name__
        classname = aliases.encode(classname)
        return classname
    
    def setstate(self, state, schema):
        if not isinstance(state, str): raise StateError(f"expected <str> instead of {state}")
        classname = aliases.decode(state)
        self.class_ = import_(classname)
        

class Dict(Value):
    """Specification of a key-value mapping where every key must be unique; wrapper for a standard <dict> type."""

class Link(Value):
    """Outgoing link to another item."""
    
    cid = None
    iid = None
    
    @property
    def id(self):
        return self.cid, self.iid
    

#####################################################################################################################################################
#####
#####  TYPE & SCHEMA definition
#####

class Type:
    """
    Base class for type definition classes.
    """

class Schema(Type):
    """Schema of items in a category, as a list of attribute names and their types."""

    attrs = None        # dict of attribute names and their Attribute specifications: {name: attribute}

class Attribute(Type):
    """
    Schema of an attribute: value type + human-readable description + multiplicity constraints.
    """
    info    = None      # human-readable description
    type_   = None      # subclass of Value represented by a Class instance
    default = None      # the value assumed if this attribute is missing in an item
    multi   = False     # whether this attribute is multi-valued (True), or max. 1 value is allowed (False)


