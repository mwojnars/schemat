import {assert, print, timeout, sleep, utc} from '../common/utils.js'
import {ServerTimeoutError} from "../common/errors.js";
import {WebRequest} from "../web/request.js";
import {WebObject} from "../core/object.js"


/**********************************************************************************************************************/

export class Agent extends WebObject {
    /* A web object that can be installed on a particular node(s) in the cluster to run a perpetual operation there (a microservice).
       Typically, the agent runs a web server, or an intra-cluster microservice of any kind, with a perpetual event loop.
       The agent is allowed to use local resources of the host node: files, sockets, etc.; with some of them (typically files)
       being allocated/deallocated in __install__/__uninstall__(), while some others (e.g., sockets) in __start__/__stop__().
    */

    __frame         // AsyncLocalStorage that holds the current Frame of this agent while its agent-method(s) is being called

    get $frame()    { return this.__frame?.getStore() }
    get $state()    { return this.$frame?.state }
    get $role()     { return this.$frame?.role }

    __ctx           // Database object that provides context of execution for __start__/__stop__/$agent.*() methods
                    // of this agent ("user mode"); if missing, kernel's context (cluster-level DB) is used ("kernel mode");
                    // behavior for $agent.*() calls can be modified with switch_context=true

    switch_context      // if true, commands are executed in the caller's context not the agent's own context (__ctx)
    num_replicas        // no. of instances of this agent that should be deployed at different workers of a node; -1 = "one per worker"
    concurrent_calls    // if true, multiple calls to this agent may execute concurrently
    file_tag            // string to be included in names of local files and directories created by this agent

    get file_path() { throw new Error(`file_path not implemented for agent ${this}`) }


    // async __install__(node) {}  // ideally, this method should be idempotent in case of failure and subsequent re-launch
    // async __uninstall__(node) {}
    //
    // __export__()     -- prepare the agent for migration/replication to another node; return a dump to be passed to __import__()
    // __import__()     -- after __install__(), import agent's state from another node using the dump generated by __export__()

    async __start__(frame) {
        /* Start the microservice implemented by this agent. Return an "execution state" which will be accessible
           to agent methods ($agent.*()) via this.$state and will be passed to __stop__() upon agent termination.
           Typically, the state object is a plain JS object with handlers to all the resources that were opened
           during __start__() and should be released in __stop__(). All calls (local or RPC) to agent methods
           are tracked to provide (optional) mutual exclusion and graceful termination.

           WARNING: state should never contain web objects, as these have limited lifetime and should be discarded
                    after their TTL, which is impossible when they are included in a long-living state.
                    Web objects in state may lead to memory leaks and to reliance on outdated information.
                    Plain IDs should be included instead, to be converted into fresh objects upon use, if needed.
         */
    }

    async __restart__(stop) {
        /* Called every time when agent object is reloaded in its frame. The default implementation stops
           the previous execution with __stop__() called in the context of the previous object - this is what stop()
           callback does - and then invokes __start__() in the context of the refreshed object (this).
           In many cases, the default stop+start implementation is an overkill and may have undesirable side effects,
           like temporary unavailability of the service. For this reason, __restart__() can be customized in subclasses.
           __restart__() may return a new state object, or directly modify this.$state and return undefined.
         */
        await stop()
        return this.__start__(this.$frame)
    }

    async __stop__(state) {
        /* Stop the agent's execution. Release any local resources that were acquired during __start__() or __restart__(). */
    }

    async app_context(fn, caller_ctx = null) {
        /* Run fn() in the app/db context expected by this agent (this.__ctx). */
        assert(this.is_loaded())
        let ctx = this.switch_context ? caller_ctx : this.__ctx
        ctx ??= schemat.kernel_context              // empty `ctx` means kernel context should be used
        return schemat.app_context(ctx, fn)
    }

    // get_placement(role = schemat.GENERIC_ROLE) {
    //     /* Return the node where this agent is deployed right now in a given role. */
    // }

    /***  RPC methods  ***/

    '$agent.pause'() {
        /* Pause the execution of this agent: execution of incoming and pending requests is on hold until $agent.resume().
           Ongoing calls are NOT affected, they run normally until completion. Mainly for debugging. Do NOT override in subclasses.
         */
        return this.$frame.pause()
    }

    '$agent.resume'() {
        return this.$frame.resume()
    }

    '$agent.background'() {
        /* Background processing to be triggered at regular intervals, usually in spare time when there are no other calls.
           The agent may control how often this operation is executed by returning the length of the next time interval (in seconds).
           A positive value means low-priority execution that waits until there's no other running/pending call.
           A negative value, -T, means a normal-priority execution that will start exactly in T seconds from now,
           even if the agent is busy with other calls. When nothing returned, the default is +60 seconds.
           Override in subclasses.
         */
        this._print(`$agent.background() ...`)
    }

    async '$agent.ping'(msg) {
        /* For testing RPC messages and intra-cluster communication. */
        let response = `[${utc()}] PING to ${this}.${this.$role}: ${msg}`
        print(response)
        return response
    }
}


/**********************************************************************************************************************/

// export class Driver extends WebObject {}


/**********************************************************************************************************************
 **
 **  WEB SERVER
 **
 */

export class WebServer extends Agent {
    /* Edge HTTP server based on express.
       For sending & receiving multipart data (HTML+JSON) in http response, see:
       - https://stackoverflow.com/a/50883981/1202674
       - https://stackoverflow.com/a/47067787/1202674
     */

    request_timeout

    async _create_server() {
        // let {ServerSchemat} = await import('/$/local/schemat/core/schemat_srv.js')
        // await schemat._reset_class(ServerSchemat)

        // schemat.registry.objects.clear()
        // await schemat._init_app()

        let express = (await import('express')).default
        let bodyParser = (await import('body-parser')).default
        let compression = (await import('compression')).default

        let xapp = express()
        xapp.use(compression())     // enable Gzip compression; reduces the size of .html and .js files by 3-4x

        // for official middleware see: https://expressjs.com/en/resources/middleware.html
        // for receiving files:
        //  - multer:      https://www.npmjs.com/package/multer and https://expressjs.com/en/5x/api.html#req.body
        //  - fileupload:  https://www.npmjs.com/package/express-fileupload & https://stackoverflow.com/a/50243907/1202674 (newer one, possibly easier)

        // // set CORS headers in all responses to allow cross-origin requests
        // xapp.use((req, res, next) => {
        //     res.header('Access-Control-Allow-Origin', '*')      // or the specific origin of your client app
        //     res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept')
        //     next()
        // })

        // xapp.use(express.json())                                 // for parsing application/json to req.body object
        xapp.use(express.urlencoded({extended: false}))             // for parsing application/x-www-form-urlencoded
        xapp.use(bodyParser.text({type: '*/*', limit: '100MB'}))    // for setting req.body string from plain-text body (if not json MIME-type)

        xapp.all('*', schemat.with_context((req, res) => this._handle(req, res)))

        let host = schemat.config.host || this.host || schemat.node.http_host
        let port = schemat.config.port || this.port || schemat.node.http_port
        let addr = `http://${host}:${port}`

        let server = xapp.listen(port, host, schemat.with_context(() => this._print(`listening at ${addr}`)))
        server.on('error', (err) => {this._print(`failed to listen at ${addr}:`, err.message)})
        return server
    }

    async __start__() {
        return {server: await this._create_server()}
    }

    async __restart__() {
        /* Start a new server while closing the old one (existing connections will run undisturbed). */
        let new_server = await this._create_server()
        this.$state.server.close()      // TODO: add timeout to make sure the server is closed
        return {server: new_server}
    }

    async __stop__({server}) {
        if (server) await new Promise(resolve => server.close(resolve))
        this._print(`WebServer closed`)
    }

    async _handle(req, res) {
        if (!['GET','POST'].includes(req.method)) return res.sendStatus(405)    // 405 Method Not Allowed
        // this._print(`handle() of ${req.method}:${req.path})`)
        // await session.start()

        // // redirection of HTTP to HTTPS
        // httpServer.on('request', (req, res) => {
        //     let httpsUrl = `https://${req.headers.host.replace(HTTP_PORT, HTTPS_PORT)}${req.url}`
        //     res.writeHead(301, { Location: httpsUrl })
        //     res.end()
        // })

        try {
            // await sleep(3)
            let request = new WebRequest({req, res})
            let handler = schemat.app.route(request)

            if (this.request_timeout) {
                let deadline = timeout(this.request_timeout * 1000, new ServerTimeoutError())
                handler = Promise.race([handler, deadline])         // the request is abandoned if it takes too long to process
            }
            let result = await handler
            if (typeof result === 'string') res.send(result)
        }
        catch (ex) {
            this._print(`web request ${req.url} FAILED with`, ex)
            if (!res.headersSent)
                if (ex.code === 'ENOENT')                           // file not found error
                    res.status(404).send('File not found')
                else
                    res.status(ex.code || 500).send(ex.message || 'Internal Server Error')
            else
                res.end()               // if headers were sent already, we need to end the response

            // TODO: send cancellation signal (StopRequest interrupt) to the Schemat to terminate all pending load-object operations and stop the remaining computation (esp. on timeout)
        }

        // // TODO: a temporary check to make sure that dynamic imports work fine; drop this in the future
        // let {check} = await schemat.app.import_module("/app/widgets.js")
        // check()

        // await schemat.after_request()
        // print(`handle() worker ${process.pid} finished: ${req.path}`)

        // await sleep(0.2)                 // for testing
        // session.printCounts()
        // await session.stop()
    }
}
